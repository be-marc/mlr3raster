% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataBackendRasterBrick.R
\name{DataBackendRasterBrick}
\alias{DataBackendRasterBrick}
\title{DataBackend for RasterBrick objects}
\description{
A \link[mlr3:DataBackend]{mlr3::DataBackend} for \code{RasterBrick} (package \CRANpkg{raster}).

The \CRANpkg{raster} package cannot deal (easily) with factor features.
Binary responses will always be converted to 0/1 values.
Multiclass values are not supported.
We highly recommend to use \code{DataBackendSpatRaster} which uses the official
successor of the \CRANpkg{raster} package, package \CRANpkg{terra}.
\CRANpkg{terra} is also faster than \CRANpkg{raster}.

To workaround the factor handling limitation and add compatibility with the
mlr3 task semantics, users need to set \code{response_is_factor = TRUE} if the
backend should be used within a classification task.

Internally, {mlr3spatial} extracts all values from the raster object and
stores these in a \code{data.table}.

The raw raster object can be returned via the active binding \code{.$stack()}.
}
\examples{
if (mlr3misc::require_namespaces("raster", quietly = TRUE)) {
  stack = demo_stack_rasterbrick(size = 5, layers = 5)
  backend = DataBackendRasterBrick$new(stack, response = "y", response_is_factor = TRUE)
}
}
\section{Super class}{
\code{\link[mlr3:DataBackend]{mlr3::DataBackend}} -> \code{DataBackendRasterBrick}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{compact_seq}}{\code{logical(1)}\cr
If \code{TRUE}, row ids are a natural sequence from 1 to \code{nrow(data)} (determined internally).
In this case, row lookup uses faster positional indices instead of equi joins.}

\item{\code{response}}{(\code{\link{character}})\cr
The name of the response variable given during construction.}

\item{\code{response_is_factor}}{(\code{\link{character}})\cr
Whether \code{response_is_factor = TRUE} was set during construction.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{rownames}}{(\code{integer()})\cr
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.}

\item{\code{colnames}}{(\code{character()})\cr
Returns vector of all column names, including the primary key column.}

\item{\code{nrow}}{(\code{integer(1)})\cr
Number of rows (observations).}

\item{\code{ncol}}{(\code{integer(1)})\cr
Number of columns (variables), including the primary key column.}

\item{\code{stack}}{(\code{integer(1)})\cr
Returns RasterBrick.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{DataBackendRasterBrick$new()}}
\item \href{#method-data}{\code{DataBackendRasterBrick$data()}}
\item \href{#method-head}{\code{DataBackendRasterBrick$head()}}
\item \href{#method-distinct}{\code{DataBackendRasterBrick$distinct()}}
\item \href{#method-missings}{\code{DataBackendRasterBrick$missings()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format">}\href{../../mlr3/html/DataBackend.html#method-format}{\code{mlr3::DataBackend$format()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print">}\href{../../mlr3/html/DataBackend.html#method-print}{\code{mlr3::DataBackend$print()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Creates a backend for a \code{RasterBrick}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendRasterBrick$new(
  data,
  primary_key = NULL,
  response,
  response_is_factor = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{(\code{RasterBrick})\cr
A raster object.}

\item{\code{primary_key}}{(\code{character(1)} | \code{integer()})\cr
Name of the primary key column, or integer vector of row ids.}

\item{\code{response}}{(\code{\link{character}})\cr
The name of the response variable. Only needed when \code{response_is_factor = TRUE}.}

\item{\code{response_is_factor}}{(\code{\link{character}})\cr
When this backend should be used in a \link[mlr3:TaskClassif]{mlr3::TaskClassif}, set \code{response_is_factor = TRUE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-data"></a>}}
\if{latex}{\out{\hypertarget{method-data}{}}}
\subsection{Method \code{data()}}{
Returns a slice of the data.
Calls \code{\link[raster:rowFromCell]{raster::rowColFromCell()}} and \code{\link[raster:getValues]{raster::getValues()}} on the spatial
object and converts it to a \code{\link[data.table:data.table]{data.table::data.table()}}.

The rows must be addressed as vector of primary key values, columns must
be referred to via column names. Queries for rows with no matching row id
and queries for columns with no matching column name are silently
ignored. Rows are guaranteed to be returned in the same order as \code{rows},
columns may be returned in an arbitrary order. Duplicated row ids result
in duplicated rows, duplicated column names lead to an exception.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendRasterBrick$data(rows, cols, data_format = "data.table")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rows}}{\code{integer()}\cr
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.}

\item{\code{cols}}{\code{character()}\cr
Column names.}

\item{\code{data_format}}{(\code{character(1)})\cr
Desired data format, e.g. \code{"data.table"} or \code{"Matrix"}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-head"></a>}}
\if{latex}{\out{\hypertarget{method-head}{}}}
\subsection{Method \code{head()}}{
Retrieve the first \code{n} rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendRasterBrick$head(n = 6L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{(\code{integer(1)})\cr
Number of rows.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{\link[data.table:data.table]{data.table::data.table()}} of the first \code{n} rows.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-distinct"></a>}}
\if{latex}{\out{\hypertarget{method-distinct}{}}}
\subsection{Method \code{distinct()}}{
Returns a named list of vectors of distinct values for each column
specified. If \code{na_rm} is \code{TRUE}, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendRasterBrick$distinct(rows, cols, na_rm = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rows}}{\code{integer()}\cr
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.}

\item{\code{cols}}{\code{character()}\cr
Column names.}

\item{\code{na_rm}}{\code{logical(1)}\cr
Whether to remove NAs or not.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Named \code{list()} of distinct values.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-missings"></a>}}
\if{latex}{\out{\hypertarget{method-missings}{}}}
\subsection{Method \code{missings()}}{
Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendRasterBrick$missings(rows, cols)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rows}}{\code{integer()}\cr
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.}

\item{\code{cols}}{\code{character()}\cr
Column names.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Total of missing values per column (named \code{numeric()}).
}
}
}
