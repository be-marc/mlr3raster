---
title: "Proof of Concept"
output: 
  rmarkdown::html_vignette:
    df_print: paged
vignette: >
  %\VignetteIndexEntry{poc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE
)
```

## Load Data

The `SpatRaster` object which is created in the following is not included as a built-in dataset into the package due to its size. 
It uses around 50 MB disk space and requires around 1.6 GB memory during creation.
Creation is a one-time task and you can make use of it in future sessions.

The `SpatRaster` consists of 3535 columns and rows and contains 5 layers with each layer representing a variable.

Do not worry about the `"Error in (function (x)  : attempt to apply non-function"` error you are seeing - this is an internal issue of the {terra} package during object creation and does not affect usage.

```{r}
library("mlr3")
library("mlr3spatial")
library("mlr3learners")
library("terra")
library("e1071")
# pkgload::load_all()
```

A mlr3 classification `task` is created and an SVM learner is fitted with randomly sampled raster cells.

```{r}
if (!file.exists("demo-stack.tif")) {
  stack = demo_stack(size = 100, layers = 5)
  terra::writeRaster(stack, "demo-stack.tif", overwrite = TRUE)
  rm(stack)
  stack = terra::rast("demo-stack.tif")
} else {
  stack = terra::rast("demo-stack.tif")
}
backend = DataBackendSpatRaster$new(stack)
task = as_task_classif(backend, target = "y", positive = "TRUE")

print(task)
```

```{r}
learner_svm = lrn("classif.svm")
# requires mlr3 > 0.12.0
learner_svm$parallel_predict = TRUE
set.seed(42)
row_ids = sample(1:task$nrow, 500)
learner_svm$train(task, row_ids = row_ids)

print(learner_svm)
```

## Prediction

For prediction `predict_spatial_newdata()` is used.
This function can operate on {terra} objects but is also able to take a `data.frame` / `data.table` directly.
It will return a `mlr3::Prediction()` object and, if argument `filename` is supplied, will also write a `.tif` file to disk.

The following prediction will happen on ~ 12.5 Mio values ($3535^2$).
We will compare the {mlr3spatial} prediction way with the "native" way of fitting an `e1071::svm()` model and predicting with `terra::predict()`.

Due to the existence of a `SpatRaster` object within the Task, `future` parallelization is not possible directly as the `SpatRaster` object contains [external pointers](https://future.futureverse.org/articles/future-4-non-exportable-objects.html?q=pointers#package-terra).
Hence we need to extract the raw values and from the object and do a prediction on a single `data.table` if we want to use future-based parallelization.

### mlr3spatial

```{r}
library(future)
plan(multisession, workers = 2)

file = tempfile("target", fileext = ".tif")
pred = predict_spatial_newdata(learner_svm, stack, filename = file)

print(pred)
```

## terra

```{r}
# fit e1071 svm
set.seed(42)
svm_raw = e1071::svm(y ~ ., data = task$data()[row_ids])

terra_pred_ras = terra::predict(task$backend$stack, svm_raw, cores = 1, cpkgs = "e1071")

print(terra_pred_ras)
```

## Output consistency

{terra} returns an integer vector as it always converts factors into numerics internally (which looks like a bug).
Also before we can do the comparison between the {mlr3spatial} and {terra} prediction, we need to load the created `target.tif` file from disk, as {mlr3spatial} returns a `mlr3::Prediction` object and not a `SpatRaster` into the current environment.

```{r}
# load mlr3 tif
mlr3_pred_ras = terra::rast(file)

# waldo::compare(head(mlr3_pred_ras), head(terra_pred_ras))
```

If we convert both to numerics

```{r}
mlr3_pred_int = as.numeric(as.data.frame(mlr3_pred_ras)$lyr.1)

terra_pred_val = as.data.frame(terra_pred_ras)$lyr1

all.equal(mlr3_pred_int, terra_pred_val)
```
